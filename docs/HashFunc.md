```java
  /**
 计算 key.hashCode() 并将高位通过异或扩散到低位。由于哈希表使用的是 2 的幂掩码，
 那些仅在当前掩码以上的位不同的哈希值集合将总是发生冲突。
 （已知的例子包括在小表中保存连续整数的 Float 键集合。）因此我们应用一种变换，
 将高位的影响向下扩散。速度、实用性和位扩散质量之间存在权衡。
 由于许多常见的哈希集合已经分布得比较均匀（因此不需要额外扩散），
 并且我们还使用树来处理桶中大量的冲突，所以我们仅以最廉价的方式
 异或一些移位的位来减少系统性损失，同时把那些否则会因为表界限
 从未用于索引计算的最高位的影响也考虑进来。 
 */
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```
这段注释的意思用通俗的话说就是：

- HashMap 要把对象的 hashCode 变成数组下标，但数组长度通常是 2 的幂，这样只看 hash 值的低几位就能得到下标。
- 如果很多对象的 hash 值在低位都相同、只有高位不同，它们会被映射到同一个槽（也就是冲突），效率会变差。
- 为了减少这种“高位信息被丢掉导致的冲突”，在把 hashCode 用作索引前，会把高位的一些比特“异或”到低位上，简单说就是把高位的信息混进低位。
- 这样做能把原本只在高位不同的值更好地分散到不同槽里，降低冲突概率。
- 这是一个折中：这种处理很便宜（计算快），虽然不是最完美的位扩散方法，但大多数情况下已经足够用；而且当冲突很多时，哈希表还会用树结构来处理，所以不需要太复杂的扩散算法。

简短总结：为了把高位信息也带到影响数组下标的低位上，HashMap 用一次简单的异或位移，把 hash 值“搅拌”一下，减少因为只看低位而造成的冲突。

## 为什么只看低几位就能得到下标

因为计算数组下标时用的是按位与（mask）而不是取模。具体原因和过程：

- HashMap 的桶数组长度 table.length 通常保持为 2 的幂（比如 16、32、64），这样做可以把除法或取模运算替换为更快的按位操作。
- 计算索引的公式通常是：index = hash & (table.length - 1)。例如 table.length = 16，则 table.length - 1 = 15（二进制 0000…1111），与运算会把 hash 的低 4 位保留下来，高位全部丢弃。
- 因此，当表长为 2 的幂时，只有 hash 的低几位（等于 log2(table.length)）决定了索引，高位不会影响索引位置——这就是“只看低几位”的原因。

举个简单例子：
- table.length = 8（2^3），mask = 7（二进制 111）。
- hash = 0b10110110，与 0b00000111 做 &，只得到低 3 位 110（即 6），作为索引。

这样做的优点是速度快（位运算比取模快），但缺点就是如果很多 hash 的低位相同而高位不同，就会产生冲突，所以才有前面注释里提到的“把高位混到低位”的做法来缓解。